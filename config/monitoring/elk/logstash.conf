# Logstash Configuration for SEC Latent Application Logs

input {
  # File input for application logs
  file {
    path => "/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    tags => ["application"]
  }

  # File input for access logs
  file {
    path => "/logs/access/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    tags => ["access"]
  }

  # Syslog input
  syslog {
    port => 5000
    type => "syslog"
    tags => ["system"]
  }

  # Beats input (for Filebeat)
  beats {
    port => 5044
    tags => ["beats"]
  }
}

filter {
  # Parse JSON logs
  if [tags] contains "application" {
    json {
      source => "message"
      target => "parsed_log"
    }

    # Extract fields
    mutate {
      add_field => {
        "log_level" => "%{[parsed_log][level]}"
        "logger_name" => "%{[parsed_log][name]}"
        "module" => "%{[parsed_log][module]}"
        "function" => "%{[parsed_log][funcName]}"
        "line_no" => "%{[parsed_log][lineno]}"
      }
    }

    # Parse timestamp
    date {
      match => ["[parsed_log][timestamp]", "ISO8601"]
      target => "@timestamp"
    }

    # Add severity level
    if [log_level] == "ERROR" or [log_level] == "CRITICAL" {
      mutate {
        add_tag => ["error"]
      }
    } else if [log_level] == "WARNING" {
      mutate {
        add_tag => ["warning"]
      }
    }
  }

  # Parse access logs
  if [tags] contains "access" {
    grok {
      match => {
        "message" => '%{IPORHOST:client_ip} - - \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}" %{NUMBER:status_code} %{NUMBER:bytes} "%{DATA:referrer}" "%{DATA:user_agent}" %{NUMBER:response_time}'
      }
    }

    # Convert response time to float
    mutate {
      convert => {
        "response_time" => "float"
        "status_code" => "integer"
        "bytes" => "integer"
      }
    }

    # Tag slow requests
    if [response_time] and [response_time] > 2.0 {
      mutate {
        add_tag => ["slow_request"]
      }
    }

    # Tag errors
    if [status_code] >= 500 {
      mutate {
        add_tag => ["server_error"]
      }
    } else if [status_code] >= 400 {
      mutate {
        add_tag => ["client_error"]
      }
    }

    # Parse user agent
    useragent {
      source => "user_agent"
      target => "ua"
    }

    # GeoIP lookup
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Parse Celery task logs
  if [logger_name] =~ /celery/ {
    mutate {
      add_tag => ["celery"]
    }

    # Extract task information
    grok {
      match => {
        "message" => "Task %{DATA:task_name}\[%{DATA:task_id}\] %{WORD:task_status}"
      }
      tag_on_failure => []
    }
  }

  # Parse database logs
  if [logger_name] =~ /sqlalchemy|database/ {
    mutate {
      add_tag => ["database"]
    }

    # Extract slow queries
    if [message] =~ /slow query/ {
      mutate {
        add_tag => ["slow_query"]
      }
    }
  }

  # Remove sensitive information
  mutate {
    remove_field => ["password", "api_key", "token", "secret"]
  }

  # Add environment metadata
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:development}"
      "service" => "sec-latent"
      "version" => "${VERSION:unknown}"
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "sec-latent-%{+YYYY.MM.dd}"
    document_type => "_doc"
    template_name => "sec-latent"
    template_overwrite => true
    manage_template => true
  }

  # Output errors to separate index
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "sec-latent-errors-%{+YYYY.MM.dd}"
      document_type => "_doc"
    }
  }

  # Output slow requests to separate index
  if "slow_request" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "sec-latent-slow-requests-%{+YYYY.MM.dd}"
      document_type => "_doc"
    }
  }

  # Debug output (comment out in production)
  # stdout {
  #   codec => rubydebug
  # }
}
